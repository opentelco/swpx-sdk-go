//
// Copyright (c) 2023. Liero AB
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.26.1
// source: core.proto

package corepb

import (
	context "context"
	analysispb "go.opentelco.io/swpx-sdk-go/analysispb"
	stanzapb "go.opentelco.io/swpx-sdk-go/stanzapb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Plugins_List_FullMethodName = "/core.Plugins/List"
)

// PluginsClient is the client API for Plugins service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginsClient interface {
	// GetPlugins returns a list of all plugins that are available in the system
	List(ctx context.Context, in *ListPluginsRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error)
}

type pluginsClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginsClient(cc grpc.ClientConnInterface) PluginsClient {
	return &pluginsClient{cc}
}

func (c *pluginsClient) List(ctx context.Context, in *ListPluginsRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error) {
	out := new(ListPluginsResponse)
	err := c.cc.Invoke(ctx, Plugins_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginsServer is the server API for Plugins service.
// All implementations should embed UnimplementedPluginsServer
// for forward compatibility
type PluginsServer interface {
	// GetPlugins returns a list of all plugins that are available in the system
	List(context.Context, *ListPluginsRequest) (*ListPluginsResponse, error)
}

// UnimplementedPluginsServer should be embedded to have forward compatible implementations.
type UnimplementedPluginsServer struct {
}

func (UnimplementedPluginsServer) List(context.Context, *ListPluginsRequest) (*ListPluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafePluginsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginsServer will
// result in compilation errors.
type UnsafePluginsServer interface {
	mustEmbedUnimplementedPluginsServer()
}

func RegisterPluginsServer(s grpc.ServiceRegistrar, srv PluginsServer) {
	s.RegisterService(&Plugins_ServiceDesc, srv)
}

func _Plugins_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPluginsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Plugins_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginsServer).List(ctx, req.(*ListPluginsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Plugins_ServiceDesc is the grpc.ServiceDesc for Plugins service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Plugins_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Plugins",
	HandlerType: (*PluginsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Plugins_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

const (
	Diagnostics_RunDiagnostic_FullMethodName      = "/core.Diagnostics/RunDiagnostic"
	Diagnostics_RunQuickDiagnostic_FullMethodName = "/core.Diagnostics/RunQuickDiagnostic"
	Diagnostics_GetDiagnostic_FullMethodName      = "/core.Diagnostics/GetDiagnostic"
	Diagnostics_ListDiagnostics_FullMethodName    = "/core.Diagnostics/ListDiagnostics"
)

// DiagnosticsClient is the client API for Diagnostics service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DiagnosticsClient interface {
	// RunDiagnostic is used to run a diagnostic on a network element or a specific port on the network element
	// It will collect data from the network element and then wait for a period of time and collect data again
	// and return the difference between the two collections of data to the client. The data will also be analyzed
	// by the poller and Report of the diagnostic will be returned to the client.
	// the diagnostic will be run the number of times specified in the request and the time between each poll is 10 seconds.
	// connecting to a device can take up to one minute depending on the device and protocol used so a standard diagnostic
	// will take aproximately 1 minute to complete.
	RunDiagnostic(ctx context.Context, in *RunDiagnosticRequest, opts ...grpc.CallOption) (*RunDiagnosticResponse, error)
	// Run a diagnostic but a quick diagnostic. This will only collect data from the network element once and then return
	RunQuickDiagnostic(ctx context.Context, in *RunQuickDiagnosticRequest, opts ...grpc.CallOption) (*RunQuickDiagnosticResponse, error)
	// GetDiagnostic returns the report of a diagnostic that has been run on a network element or a specific port on the network element
	GetDiagnostic(ctx context.Context, in *GetDiagnosticRequest, opts ...grpc.CallOption) (*analysispb.Report, error)
	// ListDiagnostics returns a list of diagnostics that has been run on a network element or a specific port on the network element
	ListDiagnostics(ctx context.Context, in *ListDiagnosticsRequest, opts ...grpc.CallOption) (*ListDiagnosticsResponse, error)
}

type diagnosticsClient struct {
	cc grpc.ClientConnInterface
}

func NewDiagnosticsClient(cc grpc.ClientConnInterface) DiagnosticsClient {
	return &diagnosticsClient{cc}
}

func (c *diagnosticsClient) RunDiagnostic(ctx context.Context, in *RunDiagnosticRequest, opts ...grpc.CallOption) (*RunDiagnosticResponse, error) {
	out := new(RunDiagnosticResponse)
	err := c.cc.Invoke(ctx, Diagnostics_RunDiagnostic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsClient) RunQuickDiagnostic(ctx context.Context, in *RunQuickDiagnosticRequest, opts ...grpc.CallOption) (*RunQuickDiagnosticResponse, error) {
	out := new(RunQuickDiagnosticResponse)
	err := c.cc.Invoke(ctx, Diagnostics_RunQuickDiagnostic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsClient) GetDiagnostic(ctx context.Context, in *GetDiagnosticRequest, opts ...grpc.CallOption) (*analysispb.Report, error) {
	out := new(analysispb.Report)
	err := c.cc.Invoke(ctx, Diagnostics_GetDiagnostic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsClient) ListDiagnostics(ctx context.Context, in *ListDiagnosticsRequest, opts ...grpc.CallOption) (*ListDiagnosticsResponse, error) {
	out := new(ListDiagnosticsResponse)
	err := c.cc.Invoke(ctx, Diagnostics_ListDiagnostics_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiagnosticsServer is the server API for Diagnostics service.
// All implementations should embed UnimplementedDiagnosticsServer
// for forward compatibility
type DiagnosticsServer interface {
	// RunDiagnostic is used to run a diagnostic on a network element or a specific port on the network element
	// It will collect data from the network element and then wait for a period of time and collect data again
	// and return the difference between the two collections of data to the client. The data will also be analyzed
	// by the poller and Report of the diagnostic will be returned to the client.
	// the diagnostic will be run the number of times specified in the request and the time between each poll is 10 seconds.
	// connecting to a device can take up to one minute depending on the device and protocol used so a standard diagnostic
	// will take aproximately 1 minute to complete.
	RunDiagnostic(context.Context, *RunDiagnosticRequest) (*RunDiagnosticResponse, error)
	// Run a diagnostic but a quick diagnostic. This will only collect data from the network element once and then return
	RunQuickDiagnostic(context.Context, *RunQuickDiagnosticRequest) (*RunQuickDiagnosticResponse, error)
	// GetDiagnostic returns the report of a diagnostic that has been run on a network element or a specific port on the network element
	GetDiagnostic(context.Context, *GetDiagnosticRequest) (*analysispb.Report, error)
	// ListDiagnostics returns a list of diagnostics that has been run on a network element or a specific port on the network element
	ListDiagnostics(context.Context, *ListDiagnosticsRequest) (*ListDiagnosticsResponse, error)
}

// UnimplementedDiagnosticsServer should be embedded to have forward compatible implementations.
type UnimplementedDiagnosticsServer struct {
}

func (UnimplementedDiagnosticsServer) RunDiagnostic(context.Context, *RunDiagnosticRequest) (*RunDiagnosticResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunDiagnostic not implemented")
}
func (UnimplementedDiagnosticsServer) RunQuickDiagnostic(context.Context, *RunQuickDiagnosticRequest) (*RunQuickDiagnosticResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunQuickDiagnostic not implemented")
}
func (UnimplementedDiagnosticsServer) GetDiagnostic(context.Context, *GetDiagnosticRequest) (*analysispb.Report, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDiagnostic not implemented")
}
func (UnimplementedDiagnosticsServer) ListDiagnostics(context.Context, *ListDiagnosticsRequest) (*ListDiagnosticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDiagnostics not implemented")
}

// UnsafeDiagnosticsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DiagnosticsServer will
// result in compilation errors.
type UnsafeDiagnosticsServer interface {
	mustEmbedUnimplementedDiagnosticsServer()
}

func RegisterDiagnosticsServer(s grpc.ServiceRegistrar, srv DiagnosticsServer) {
	s.RegisterService(&Diagnostics_ServiceDesc, srv)
}

func _Diagnostics_RunDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunDiagnosticRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).RunDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_RunDiagnostic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).RunDiagnostic(ctx, req.(*RunDiagnosticRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnostics_RunQuickDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunQuickDiagnosticRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).RunQuickDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_RunQuickDiagnostic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).RunQuickDiagnostic(ctx, req.(*RunQuickDiagnosticRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnostics_GetDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiagnosticRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).GetDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_GetDiagnostic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).GetDiagnostic(ctx, req.(*GetDiagnosticRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnostics_ListDiagnostics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDiagnosticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).ListDiagnostics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_ListDiagnostics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).ListDiagnostics(ctx, req.(*ListDiagnosticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Diagnostics_ServiceDesc is the grpc.ServiceDesc for Diagnostics service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Diagnostics_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Diagnostics",
	HandlerType: (*DiagnosticsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunDiagnostic",
			Handler:    _Diagnostics_RunDiagnostic_Handler,
		},
		{
			MethodName: "RunQuickDiagnostic",
			Handler:    _Diagnostics_RunQuickDiagnostic_Handler,
		},
		{
			MethodName: "GetDiagnostic",
			Handler:    _Diagnostics_GetDiagnostic_Handler,
		},
		{
			MethodName: "ListDiagnostics",
			Handler:    _Diagnostics_ListDiagnostics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

const (
	Poller_Discover_FullMethodName                      = "/core.Poller/Discover"
	Poller_CheckAvailability_FullMethodName             = "/core.Poller/CheckAvailability"
	Poller_CollectDeviceInformation_FullMethodName      = "/core.Poller/CollectDeviceInformation"
	Poller_CollectBasicDeviceInformation_FullMethodName = "/core.Poller/CollectBasicDeviceInformation"
	Poller_CollectPortInformation_FullMethodName        = "/core.Poller/CollectPortInformation"
	Poller_CollectBasicPortInformation_FullMethodName   = "/core.Poller/CollectBasicPortInformation"
	Poller_CollectConfig_FullMethodName                 = "/core.Poller/CollectConfig"
)

// PollerClient is the client API for Poller service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PollerClient interface {
	// Discover is used to get basic information about an network element, used to make a quick check of the device
	// using the generic resource plugin to make request through resource.GetDeiceInformation
	Discover(ctx context.Context, in *DiscoverRequest, opts ...grpc.CallOption) (*DiscoverResponse, error)
	// CheckAvailability is used to check if a network element is available and responding to requests
	// this does not imply that the network element is working correctly or that it is configured correctly but
	// that it is responding to requests and that the poller can connect to it over SNMP/ICMP
	// the availability also verifys checking that hostname is resolvable (if hostname is used in the request)
	CheckAvailability(ctx context.Context, in *CheckAvailabilityRequest, opts ...grpc.CallOption) (*CheckAvailabilityResponse, error)
	// GetDeviceInformation returns the technical information about a device
	// port etc is not considered in this request
	CollectDeviceInformation(ctx context.Context, in *CollectDeviceInformationRequest, opts ...grpc.CallOption) (*DeviceInformationResponse, error)
	// get basic information about a device
	// port etc is not considered in this request
	CollectBasicDeviceInformation(ctx context.Context, in *CollectBasicDeviceInformationRequest, opts ...grpc.CallOption) (*DeviceInformationResponse, error)
	// Get port information about a Port. This should be used to get the full configuration of the port
	// or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 1 min to return, for a quick overview use the BasicPortInformation method
	//   - Basic info with MAC Address
	//   - Configuration
	//   - Statistics
	//   - Transceiver Information
	//   - ACL / QoS
	//   - DHCP Table
	//   - MAC Table
	CollectPortInformation(ctx context.Context, in *CollectPortInformationRequest, opts ...grpc.CallOption) (*PortInformationResponse, error)
	// CollectBasicPortInformation returns information about a port on a device. This should only take a few seconds to return
	// so it can be used to get a quick overview of the port. This should not be used to get
	// the full configuration of the port or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 5-10 seconds to return, for a more extensive information use the CollectPortInformation method
	//   - Basic info with MAC Address
	//   - Statistics
	//   - Transceiver Information (if possible to do quickly)
	CollectBasicPortInformation(ctx context.Context, in *CollectBasicPortInformationRequest, opts ...grpc.CallOption) (*PortInformationResponse, error)
	// CollectConfig collects the configuration of a network element check for any changes between the stored config and the
	// collected one. Returs a list of changes and the config collected from the network element
	CollectConfig(ctx context.Context, in *CollectConfigRequest, opts ...grpc.CallOption) (*CollectConfigResponse, error)
}

type pollerClient struct {
	cc grpc.ClientConnInterface
}

func NewPollerClient(cc grpc.ClientConnInterface) PollerClient {
	return &pollerClient{cc}
}

func (c *pollerClient) Discover(ctx context.Context, in *DiscoverRequest, opts ...grpc.CallOption) (*DiscoverResponse, error) {
	out := new(DiscoverResponse)
	err := c.cc.Invoke(ctx, Poller_Discover_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CheckAvailability(ctx context.Context, in *CheckAvailabilityRequest, opts ...grpc.CallOption) (*CheckAvailabilityResponse, error) {
	out := new(CheckAvailabilityResponse)
	err := c.cc.Invoke(ctx, Poller_CheckAvailability_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CollectDeviceInformation(ctx context.Context, in *CollectDeviceInformationRequest, opts ...grpc.CallOption) (*DeviceInformationResponse, error) {
	out := new(DeviceInformationResponse)
	err := c.cc.Invoke(ctx, Poller_CollectDeviceInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CollectBasicDeviceInformation(ctx context.Context, in *CollectBasicDeviceInformationRequest, opts ...grpc.CallOption) (*DeviceInformationResponse, error) {
	out := new(DeviceInformationResponse)
	err := c.cc.Invoke(ctx, Poller_CollectBasicDeviceInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CollectPortInformation(ctx context.Context, in *CollectPortInformationRequest, opts ...grpc.CallOption) (*PortInformationResponse, error) {
	out := new(PortInformationResponse)
	err := c.cc.Invoke(ctx, Poller_CollectPortInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CollectBasicPortInformation(ctx context.Context, in *CollectBasicPortInformationRequest, opts ...grpc.CallOption) (*PortInformationResponse, error) {
	out := new(PortInformationResponse)
	err := c.cc.Invoke(ctx, Poller_CollectBasicPortInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CollectConfig(ctx context.Context, in *CollectConfigRequest, opts ...grpc.CallOption) (*CollectConfigResponse, error) {
	out := new(CollectConfigResponse)
	err := c.cc.Invoke(ctx, Poller_CollectConfig_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PollerServer is the server API for Poller service.
// All implementations should embed UnimplementedPollerServer
// for forward compatibility
type PollerServer interface {
	// Discover is used to get basic information about an network element, used to make a quick check of the device
	// using the generic resource plugin to make request through resource.GetDeiceInformation
	Discover(context.Context, *DiscoverRequest) (*DiscoverResponse, error)
	// CheckAvailability is used to check if a network element is available and responding to requests
	// this does not imply that the network element is working correctly or that it is configured correctly but
	// that it is responding to requests and that the poller can connect to it over SNMP/ICMP
	// the availability also verifys checking that hostname is resolvable (if hostname is used in the request)
	CheckAvailability(context.Context, *CheckAvailabilityRequest) (*CheckAvailabilityResponse, error)
	// GetDeviceInformation returns the technical information about a device
	// port etc is not considered in this request
	CollectDeviceInformation(context.Context, *CollectDeviceInformationRequest) (*DeviceInformationResponse, error)
	// get basic information about a device
	// port etc is not considered in this request
	CollectBasicDeviceInformation(context.Context, *CollectBasicDeviceInformationRequest) (*DeviceInformationResponse, error)
	// Get port information about a Port. This should be used to get the full configuration of the port
	// or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 1 min to return, for a quick overview use the BasicPortInformation method
	//   - Basic info with MAC Address
	//   - Configuration
	//   - Statistics
	//   - Transceiver Information
	//   - ACL / QoS
	//   - DHCP Table
	//   - MAC Table
	CollectPortInformation(context.Context, *CollectPortInformationRequest) (*PortInformationResponse, error)
	// CollectBasicPortInformation returns information about a port on a device. This should only take a few seconds to return
	// so it can be used to get a quick overview of the port. This should not be used to get
	// the full configuration of the port or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 5-10 seconds to return, for a more extensive information use the CollectPortInformation method
	//   - Basic info with MAC Address
	//   - Statistics
	//   - Transceiver Information (if possible to do quickly)
	CollectBasicPortInformation(context.Context, *CollectBasicPortInformationRequest) (*PortInformationResponse, error)
	// CollectConfig collects the configuration of a network element check for any changes between the stored config and the
	// collected one. Returs a list of changes and the config collected from the network element
	CollectConfig(context.Context, *CollectConfigRequest) (*CollectConfigResponse, error)
}

// UnimplementedPollerServer should be embedded to have forward compatible implementations.
type UnimplementedPollerServer struct {
}

func (UnimplementedPollerServer) Discover(context.Context, *DiscoverRequest) (*DiscoverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Discover not implemented")
}
func (UnimplementedPollerServer) CheckAvailability(context.Context, *CheckAvailabilityRequest) (*CheckAvailabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckAvailability not implemented")
}
func (UnimplementedPollerServer) CollectDeviceInformation(context.Context, *CollectDeviceInformationRequest) (*DeviceInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectDeviceInformation not implemented")
}
func (UnimplementedPollerServer) CollectBasicDeviceInformation(context.Context, *CollectBasicDeviceInformationRequest) (*DeviceInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectBasicDeviceInformation not implemented")
}
func (UnimplementedPollerServer) CollectPortInformation(context.Context, *CollectPortInformationRequest) (*PortInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectPortInformation not implemented")
}
func (UnimplementedPollerServer) CollectBasicPortInformation(context.Context, *CollectBasicPortInformationRequest) (*PortInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectBasicPortInformation not implemented")
}
func (UnimplementedPollerServer) CollectConfig(context.Context, *CollectConfigRequest) (*CollectConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectConfig not implemented")
}

// UnsafePollerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PollerServer will
// result in compilation errors.
type UnsafePollerServer interface {
	mustEmbedUnimplementedPollerServer()
}

func RegisterPollerServer(s grpc.ServiceRegistrar, srv PollerServer) {
	s.RegisterService(&Poller_ServiceDesc, srv)
}

func _Poller_Discover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).Discover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_Discover_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).Discover(ctx, req.(*DiscoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CheckAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAvailabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CheckAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CheckAvailability_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CheckAvailability(ctx, req.(*CheckAvailabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CollectDeviceInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectDeviceInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CollectDeviceInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CollectDeviceInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CollectDeviceInformation(ctx, req.(*CollectDeviceInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CollectBasicDeviceInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectBasicDeviceInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CollectBasicDeviceInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CollectBasicDeviceInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CollectBasicDeviceInformation(ctx, req.(*CollectBasicDeviceInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CollectPortInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectPortInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CollectPortInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CollectPortInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CollectPortInformation(ctx, req.(*CollectPortInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CollectBasicPortInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectBasicPortInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CollectBasicPortInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CollectBasicPortInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CollectBasicPortInformation(ctx, req.(*CollectBasicPortInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CollectConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CollectConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CollectConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CollectConfig(ctx, req.(*CollectConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Poller_ServiceDesc is the grpc.ServiceDesc for Poller service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Poller_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Poller",
	HandlerType: (*PollerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Discover",
			Handler:    _Poller_Discover_Handler,
		},
		{
			MethodName: "CheckAvailability",
			Handler:    _Poller_CheckAvailability_Handler,
		},
		{
			MethodName: "CollectDeviceInformation",
			Handler:    _Poller_CollectDeviceInformation_Handler,
		},
		{
			MethodName: "CollectBasicDeviceInformation",
			Handler:    _Poller_CollectBasicDeviceInformation_Handler,
		},
		{
			MethodName: "CollectPortInformation",
			Handler:    _Poller_CollectPortInformation_Handler,
		},
		{
			MethodName: "CollectBasicPortInformation",
			Handler:    _Poller_CollectBasicPortInformation_Handler,
		},
		{
			MethodName: "CollectConfig",
			Handler:    _Poller_CollectConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

const (
	Commander_ConfigureStanza_FullMethodName = "/core.Commander/ConfigureStanza"
)

// CommanderClient is the client API for Commander service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommanderClient interface {
	// configure a configuration stanza on a network element
	ConfigureStanza(ctx context.Context, in *ConfigureStanzaRequest, opts ...grpc.CallOption) (*stanzapb.ConfigureResponse, error)
}

type commanderClient struct {
	cc grpc.ClientConnInterface
}

func NewCommanderClient(cc grpc.ClientConnInterface) CommanderClient {
	return &commanderClient{cc}
}

func (c *commanderClient) ConfigureStanza(ctx context.Context, in *ConfigureStanzaRequest, opts ...grpc.CallOption) (*stanzapb.ConfigureResponse, error) {
	out := new(stanzapb.ConfigureResponse)
	err := c.cc.Invoke(ctx, Commander_ConfigureStanza_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommanderServer is the server API for Commander service.
// All implementations should embed UnimplementedCommanderServer
// for forward compatibility
type CommanderServer interface {
	// configure a configuration stanza on a network element
	ConfigureStanza(context.Context, *ConfigureStanzaRequest) (*stanzapb.ConfigureResponse, error)
}

// UnimplementedCommanderServer should be embedded to have forward compatible implementations.
type UnimplementedCommanderServer struct {
}

func (UnimplementedCommanderServer) ConfigureStanza(context.Context, *ConfigureStanzaRequest) (*stanzapb.ConfigureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureStanza not implemented")
}

// UnsafeCommanderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommanderServer will
// result in compilation errors.
type UnsafeCommanderServer interface {
	mustEmbedUnimplementedCommanderServer()
}

func RegisterCommanderServer(s grpc.ServiceRegistrar, srv CommanderServer) {
	s.RegisterService(&Commander_ServiceDesc, srv)
}

func _Commander_ConfigureStanza_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureStanzaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommanderServer).ConfigureStanza(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Commander_ConfigureStanza_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommanderServer).ConfigureStanza(ctx, req.(*ConfigureStanzaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Commander_ServiceDesc is the grpc.ServiceDesc for Commander service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Commander_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Commander",
	HandlerType: (*CommanderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigureStanza",
			Handler:    _Commander_ConfigureStanza_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

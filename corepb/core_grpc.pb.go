//
// Copyright (c) 2023. Liero AB
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.26.1
// source: core.proto

package corepb

import (
	context "context"
	analysispb "go.opentelco.io/swpx-sdk-go/analysispb"
	stanzapb "go.opentelco.io/swpx-sdk-go/stanzapb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Plugins_List_FullMethodName = "/core.Plugins/List"
)

// PluginsClient is the client API for Plugins service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginsClient interface {
	// GetPlugins returns a list of all plugins that are available in the system
	List(ctx context.Context, in *ListPluginsRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error)
}

type pluginsClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginsClient(cc grpc.ClientConnInterface) PluginsClient {
	return &pluginsClient{cc}
}

func (c *pluginsClient) List(ctx context.Context, in *ListPluginsRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error) {
	out := new(ListPluginsResponse)
	err := c.cc.Invoke(ctx, Plugins_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginsServer is the server API for Plugins service.
// All implementations should embed UnimplementedPluginsServer
// for forward compatibility
type PluginsServer interface {
	// GetPlugins returns a list of all plugins that are available in the system
	List(context.Context, *ListPluginsRequest) (*ListPluginsResponse, error)
}

// UnimplementedPluginsServer should be embedded to have forward compatible implementations.
type UnimplementedPluginsServer struct {
}

func (UnimplementedPluginsServer) List(context.Context, *ListPluginsRequest) (*ListPluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafePluginsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginsServer will
// result in compilation errors.
type UnsafePluginsServer interface {
	mustEmbedUnimplementedPluginsServer()
}

func RegisterPluginsServer(s grpc.ServiceRegistrar, srv PluginsServer) {
	s.RegisterService(&Plugins_ServiceDesc, srv)
}

func _Plugins_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPluginsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Plugins_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginsServer).List(ctx, req.(*ListPluginsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Plugins_ServiceDesc is the grpc.ServiceDesc for Plugins service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Plugins_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Plugins",
	HandlerType: (*PluginsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Plugins_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

const (
	Signatures_Collect_FullMethodName          = "/core.Signatures/Collect"
	Signatures_GetCollections_FullMethodName   = "/core.Signatures/GetCollections"
	Signatures_GetCollection_FullMethodName    = "/core.Signatures/GetCollection"
	Signatures_UploadCollection_FullMethodName = "/core.Signatures/UploadCollection"
	Signatures_RemoveCollection_FullMethodName = "/core.Signatures/RemoveCollection"
	Signatures_Compare_FullMethodName          = "/core.Signatures/Compare"
)

// SignaturesClient is the client API for Signatures service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SignaturesClient interface {
	// Collect is used to collect the signatures of all ports on a device
	// or a specific port on the device.
	//   - DHCP Table & MAC Table
	//   - Port Link Status
	//   - SFP Transceiver Information
	Collect(ctx context.Context, in *CollectSignaturesRequest, opts ...grpc.CallOption) (*CollectSignaturesResponse, error)
	// GetCollections returns a list of all collections that has been collected, the list can be filtered
	// by device, regions, timestamp etc. The list only contains a sumary of the collection and not the
	// full collection. To get the full collection use the GetCollection method
	GetCollections(ctx context.Context, in *GetCollectionsRequest, opts ...grpc.CallOption) (*GetCollectionsResponse, error)
	// GetCollection returns a single collection that has been collected, the collection contains all the data that was collected from the device
	GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*GetCollectionResponse, error)
	// UploadCollection is used to upload a collection to the database and store it for later use
	UploadCollection(ctx context.Context, in *UploadCollectionRequest, opts ...grpc.CallOption) (*UploadCollectionResponse, error)
	// RemoveCollection is used to remove a collection from the database
	RemoveCollection(ctx context.Context, in *RemoveCollectionRequest, opts ...grpc.CallOption) (*RemoveCollectionResponse, error)
	// Compare is used to compare 1-n signature collections with 1-n signature collections
	// The previous 1-n collections are merged together to create a baseline of how the
	// device looked before the change. Port status will be taken from the last collection
	// and the rest of the data will be taken from the merged collection. The new 1-n collections
	// will be compared to the baseline and the differences will be returned to the client.
	Compare(ctx context.Context, in *CompareRequest, opts ...grpc.CallOption) (*CompareResponse, error)
}

type signaturesClient struct {
	cc grpc.ClientConnInterface
}

func NewSignaturesClient(cc grpc.ClientConnInterface) SignaturesClient {
	return &signaturesClient{cc}
}

func (c *signaturesClient) Collect(ctx context.Context, in *CollectSignaturesRequest, opts ...grpc.CallOption) (*CollectSignaturesResponse, error) {
	out := new(CollectSignaturesResponse)
	err := c.cc.Invoke(ctx, Signatures_Collect_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signaturesClient) GetCollections(ctx context.Context, in *GetCollectionsRequest, opts ...grpc.CallOption) (*GetCollectionsResponse, error) {
	out := new(GetCollectionsResponse)
	err := c.cc.Invoke(ctx, Signatures_GetCollections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signaturesClient) GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*GetCollectionResponse, error) {
	out := new(GetCollectionResponse)
	err := c.cc.Invoke(ctx, Signatures_GetCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signaturesClient) UploadCollection(ctx context.Context, in *UploadCollectionRequest, opts ...grpc.CallOption) (*UploadCollectionResponse, error) {
	out := new(UploadCollectionResponse)
	err := c.cc.Invoke(ctx, Signatures_UploadCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signaturesClient) RemoveCollection(ctx context.Context, in *RemoveCollectionRequest, opts ...grpc.CallOption) (*RemoveCollectionResponse, error) {
	out := new(RemoveCollectionResponse)
	err := c.cc.Invoke(ctx, Signatures_RemoveCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signaturesClient) Compare(ctx context.Context, in *CompareRequest, opts ...grpc.CallOption) (*CompareResponse, error) {
	out := new(CompareResponse)
	err := c.cc.Invoke(ctx, Signatures_Compare_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SignaturesServer is the server API for Signatures service.
// All implementations should embed UnimplementedSignaturesServer
// for forward compatibility
type SignaturesServer interface {
	// Collect is used to collect the signatures of all ports on a device
	// or a specific port on the device.
	//   - DHCP Table & MAC Table
	//   - Port Link Status
	//   - SFP Transceiver Information
	Collect(context.Context, *CollectSignaturesRequest) (*CollectSignaturesResponse, error)
	// GetCollections returns a list of all collections that has been collected, the list can be filtered
	// by device, regions, timestamp etc. The list only contains a sumary of the collection and not the
	// full collection. To get the full collection use the GetCollection method
	GetCollections(context.Context, *GetCollectionsRequest) (*GetCollectionsResponse, error)
	// GetCollection returns a single collection that has been collected, the collection contains all the data that was collected from the device
	GetCollection(context.Context, *GetCollectionRequest) (*GetCollectionResponse, error)
	// UploadCollection is used to upload a collection to the database and store it for later use
	UploadCollection(context.Context, *UploadCollectionRequest) (*UploadCollectionResponse, error)
	// RemoveCollection is used to remove a collection from the database
	RemoveCollection(context.Context, *RemoveCollectionRequest) (*RemoveCollectionResponse, error)
	// Compare is used to compare 1-n signature collections with 1-n signature collections
	// The previous 1-n collections are merged together to create a baseline of how the
	// device looked before the change. Port status will be taken from the last collection
	// and the rest of the data will be taken from the merged collection. The new 1-n collections
	// will be compared to the baseline and the differences will be returned to the client.
	Compare(context.Context, *CompareRequest) (*CompareResponse, error)
}

// UnimplementedSignaturesServer should be embedded to have forward compatible implementations.
type UnimplementedSignaturesServer struct {
}

func (UnimplementedSignaturesServer) Collect(context.Context, *CollectSignaturesRequest) (*CollectSignaturesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Collect not implemented")
}
func (UnimplementedSignaturesServer) GetCollections(context.Context, *GetCollectionsRequest) (*GetCollectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCollections not implemented")
}
func (UnimplementedSignaturesServer) GetCollection(context.Context, *GetCollectionRequest) (*GetCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCollection not implemented")
}
func (UnimplementedSignaturesServer) UploadCollection(context.Context, *UploadCollectionRequest) (*UploadCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadCollection not implemented")
}
func (UnimplementedSignaturesServer) RemoveCollection(context.Context, *RemoveCollectionRequest) (*RemoveCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCollection not implemented")
}
func (UnimplementedSignaturesServer) Compare(context.Context, *CompareRequest) (*CompareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Compare not implemented")
}

// UnsafeSignaturesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SignaturesServer will
// result in compilation errors.
type UnsafeSignaturesServer interface {
	mustEmbedUnimplementedSignaturesServer()
}

func RegisterSignaturesServer(s grpc.ServiceRegistrar, srv SignaturesServer) {
	s.RegisterService(&Signatures_ServiceDesc, srv)
}

func _Signatures_Collect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectSignaturesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).Collect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_Collect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).Collect(ctx, req.(*CollectSignaturesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signatures_GetCollections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).GetCollections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_GetCollections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).GetCollections(ctx, req.(*GetCollectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signatures_GetCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).GetCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_GetCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).GetCollection(ctx, req.(*GetCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signatures_UploadCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).UploadCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_UploadCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).UploadCollection(ctx, req.(*UploadCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signatures_RemoveCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).RemoveCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_RemoveCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).RemoveCollection(ctx, req.(*RemoveCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signatures_Compare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).Compare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_Compare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).Compare(ctx, req.(*CompareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Signatures_ServiceDesc is the grpc.ServiceDesc for Signatures service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Signatures_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Signatures",
	HandlerType: (*SignaturesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Collect",
			Handler:    _Signatures_Collect_Handler,
		},
		{
			MethodName: "GetCollections",
			Handler:    _Signatures_GetCollections_Handler,
		},
		{
			MethodName: "GetCollection",
			Handler:    _Signatures_GetCollection_Handler,
		},
		{
			MethodName: "UploadCollection",
			Handler:    _Signatures_UploadCollection_Handler,
		},
		{
			MethodName: "RemoveCollection",
			Handler:    _Signatures_RemoveCollection_Handler,
		},
		{
			MethodName: "Compare",
			Handler:    _Signatures_Compare_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

const (
	Diagnostics_RunDiagnostic_FullMethodName      = "/core.Diagnostics/RunDiagnostic"
	Diagnostics_RunQuickDiagnostic_FullMethodName = "/core.Diagnostics/RunQuickDiagnostic"
	Diagnostics_GetDiagnostic_FullMethodName      = "/core.Diagnostics/GetDiagnostic"
	Diagnostics_ListDiagnostics_FullMethodName    = "/core.Diagnostics/ListDiagnostics"
)

// DiagnosticsClient is the client API for Diagnostics service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DiagnosticsClient interface {
	// RunDiagnostic is used to run a diagnostic on a network element or a specific port on the network element
	// It will collect data from the network element and then wait for a period of time and collect data again
	// and return the difference between the two collections of data to the client. The data will also be analyzed
	// by the poller and Report of the diagnostic will be returned to the client.
	// the diagnostic will be run the number of times specified in the request and the time between each poll is 10 seconds.
	// connecting to a device can take up to one minute depending on the device and protocol used so a standard diagnostic
	// will take aproximately 1 minute to complete.
	RunDiagnostic(ctx context.Context, in *RunDiagnosticRequest, opts ...grpc.CallOption) (*RunDiagnosticResponse, error)
	// Run a diagnostic but a quick diagnostic. This will only collect data from the network element once and then return
	RunQuickDiagnostic(ctx context.Context, in *RunQuickDiagnosticRequest, opts ...grpc.CallOption) (*RunQuickDiagnosticResponse, error)
	// GetDiagnostic returns the report of a diagnostic that has been run on a network element or a specific port on the network element
	GetDiagnostic(ctx context.Context, in *GetDiagnosticRequest, opts ...grpc.CallOption) (*analysispb.Report, error)
	// ListDiagnostics returns a list of diagnostics that has been run on a network element or a specific port on the network element
	ListDiagnostics(ctx context.Context, in *ListDiagnosticsRequest, opts ...grpc.CallOption) (*ListDiagnosticsResponse, error)
}

type diagnosticsClient struct {
	cc grpc.ClientConnInterface
}

func NewDiagnosticsClient(cc grpc.ClientConnInterface) DiagnosticsClient {
	return &diagnosticsClient{cc}
}

func (c *diagnosticsClient) RunDiagnostic(ctx context.Context, in *RunDiagnosticRequest, opts ...grpc.CallOption) (*RunDiagnosticResponse, error) {
	out := new(RunDiagnosticResponse)
	err := c.cc.Invoke(ctx, Diagnostics_RunDiagnostic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsClient) RunQuickDiagnostic(ctx context.Context, in *RunQuickDiagnosticRequest, opts ...grpc.CallOption) (*RunQuickDiagnosticResponse, error) {
	out := new(RunQuickDiagnosticResponse)
	err := c.cc.Invoke(ctx, Diagnostics_RunQuickDiagnostic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsClient) GetDiagnostic(ctx context.Context, in *GetDiagnosticRequest, opts ...grpc.CallOption) (*analysispb.Report, error) {
	out := new(analysispb.Report)
	err := c.cc.Invoke(ctx, Diagnostics_GetDiagnostic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsClient) ListDiagnostics(ctx context.Context, in *ListDiagnosticsRequest, opts ...grpc.CallOption) (*ListDiagnosticsResponse, error) {
	out := new(ListDiagnosticsResponse)
	err := c.cc.Invoke(ctx, Diagnostics_ListDiagnostics_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiagnosticsServer is the server API for Diagnostics service.
// All implementations should embed UnimplementedDiagnosticsServer
// for forward compatibility
type DiagnosticsServer interface {
	// RunDiagnostic is used to run a diagnostic on a network element or a specific port on the network element
	// It will collect data from the network element and then wait for a period of time and collect data again
	// and return the difference between the two collections of data to the client. The data will also be analyzed
	// by the poller and Report of the diagnostic will be returned to the client.
	// the diagnostic will be run the number of times specified in the request and the time between each poll is 10 seconds.
	// connecting to a device can take up to one minute depending on the device and protocol used so a standard diagnostic
	// will take aproximately 1 minute to complete.
	RunDiagnostic(context.Context, *RunDiagnosticRequest) (*RunDiagnosticResponse, error)
	// Run a diagnostic but a quick diagnostic. This will only collect data from the network element once and then return
	RunQuickDiagnostic(context.Context, *RunQuickDiagnosticRequest) (*RunQuickDiagnosticResponse, error)
	// GetDiagnostic returns the report of a diagnostic that has been run on a network element or a specific port on the network element
	GetDiagnostic(context.Context, *GetDiagnosticRequest) (*analysispb.Report, error)
	// ListDiagnostics returns a list of diagnostics that has been run on a network element or a specific port on the network element
	ListDiagnostics(context.Context, *ListDiagnosticsRequest) (*ListDiagnosticsResponse, error)
}

// UnimplementedDiagnosticsServer should be embedded to have forward compatible implementations.
type UnimplementedDiagnosticsServer struct {
}

func (UnimplementedDiagnosticsServer) RunDiagnostic(context.Context, *RunDiagnosticRequest) (*RunDiagnosticResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunDiagnostic not implemented")
}
func (UnimplementedDiagnosticsServer) RunQuickDiagnostic(context.Context, *RunQuickDiagnosticRequest) (*RunQuickDiagnosticResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunQuickDiagnostic not implemented")
}
func (UnimplementedDiagnosticsServer) GetDiagnostic(context.Context, *GetDiagnosticRequest) (*analysispb.Report, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDiagnostic not implemented")
}
func (UnimplementedDiagnosticsServer) ListDiagnostics(context.Context, *ListDiagnosticsRequest) (*ListDiagnosticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDiagnostics not implemented")
}

// UnsafeDiagnosticsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DiagnosticsServer will
// result in compilation errors.
type UnsafeDiagnosticsServer interface {
	mustEmbedUnimplementedDiagnosticsServer()
}

func RegisterDiagnosticsServer(s grpc.ServiceRegistrar, srv DiagnosticsServer) {
	s.RegisterService(&Diagnostics_ServiceDesc, srv)
}

func _Diagnostics_RunDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunDiagnosticRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).RunDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_RunDiagnostic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).RunDiagnostic(ctx, req.(*RunDiagnosticRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnostics_RunQuickDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunQuickDiagnosticRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).RunQuickDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_RunQuickDiagnostic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).RunQuickDiagnostic(ctx, req.(*RunQuickDiagnosticRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnostics_GetDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiagnosticRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).GetDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_GetDiagnostic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).GetDiagnostic(ctx, req.(*GetDiagnosticRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnostics_ListDiagnostics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDiagnosticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).ListDiagnostics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_ListDiagnostics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).ListDiagnostics(ctx, req.(*ListDiagnosticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Diagnostics_ServiceDesc is the grpc.ServiceDesc for Diagnostics service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Diagnostics_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Diagnostics",
	HandlerType: (*DiagnosticsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunDiagnostic",
			Handler:    _Diagnostics_RunDiagnostic_Handler,
		},
		{
			MethodName: "RunQuickDiagnostic",
			Handler:    _Diagnostics_RunQuickDiagnostic_Handler,
		},
		{
			MethodName: "GetDiagnostic",
			Handler:    _Diagnostics_GetDiagnostic_Handler,
		},
		{
			MethodName: "ListDiagnostics",
			Handler:    _Diagnostics_ListDiagnostics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

const (
	Poller_RequestTerminal_FullMethodName           = "/core.Poller/RequestTerminal"
	Poller_OpenTerminal_FullMethodName              = "/core.Poller/OpenTerminal"
	Poller_ListTerminals_FullMethodName             = "/core.Poller/ListTerminals"
	Poller_GetTerminal_FullMethodName               = "/core.Poller/GetTerminal"
	Poller_DiscoverDevice_FullMethodName            = "/core.Poller/DiscoverDevice"
	Poller_GetDeviceAvailability_FullMethodName     = "/core.Poller/GetDeviceAvailability"
	Poller_GetDeviceInformation_FullMethodName      = "/core.Poller/GetDeviceInformation"
	Poller_GetBasicDeviceInformation_FullMethodName = "/core.Poller/GetBasicDeviceInformation"
	Poller_GetPortInformation_FullMethodName        = "/core.Poller/GetPortInformation"
	Poller_GetBasicPortInformation_FullMethodName   = "/core.Poller/GetBasicPortInformation"
	Poller_GetBasicPortsInformation_FullMethodName  = "/core.Poller/GetBasicPortsInformation"
	Poller_GetRunningConfiguration_FullMethodName   = "/core.Poller/GetRunningConfiguration"
	Poller_GetDeviceNeighbors_FullMethodName        = "/core.Poller/GetDeviceNeighbors"
)

// PollerClient is the client API for Poller service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PollerClient interface {
	// RequestTerminal is used to request a terminal on a network element to run commands on the network element
	// it returns a gRRPC stream endpoint that the client to connect to and run commands on the network element
	RequestTerminal(ctx context.Context, in *RequestTerminalRequest, opts ...grpc.CallOption) (*RequestTerminalResponse, error)
	// open the terminal that was created by the rpc RequestTerminal
	// the terminal is a gRPC stream that the client can connect to and send commands to the network device
	// to connect headers needs to be added to the request
	//   - stream-id: the ID of the created session (returned by the Request Terminal)
	//   - stream-addr: the address of the agent that the Poller needs to connect to
	OpenTerminal(ctx context.Context, opts ...grpc.CallOption) (Poller_OpenTerminalClient, error)
	// ListTerminals is used to list all terminals that are open at the moment and all terminals that has been opened
	ListTerminals(ctx context.Context, in *ListTerminalsRequest, opts ...grpc.CallOption) (*ListTerminalsResponse, error)
	// Get a singel temrinal by its ID
	GetTerminal(ctx context.Context, in *GetTerminalRequest, opts ...grpc.CallOption) (*TerminalSession, error)
	// DiscoverDevice is used to get basic information about an network element, used to make a quick check of the device
	// using the generic resource plugin to make request through resource.GetDeiceInformation
	DiscoverDevice(ctx context.Context, in *DiscoverDeviceRequest, opts ...grpc.CallOption) (*DiscoverDeviceResponse, error)
	// GetDeviceAvailability is used to check if a network element is available and responding to requests
	// this does not imply that the network element is working correctly or that it is configured correctly but
	// that it is responding to requests and that the poller can connect to it over SNMP/ICMP
	// the availability also verifys checking that hostname is resolvable (if hostname is used in the request)
	GetDeviceAvailability(ctx context.Context, in *GetDeviceAvailabilityRequest, opts ...grpc.CallOption) (*GetDeviceAvailabilityResponse, error)
	// GetDeviceInformation returns the technical information about a device
	// port etc is not considered in this request
	GetDeviceInformation(ctx context.Context, in *GetDeviceInformationRequest, opts ...grpc.CallOption) (*GetDeviceInformationResponse, error)
	// get basic information about a device
	// port etc is not considered in this request
	GetBasicDeviceInformation(ctx context.Context, in *GetBasicDeviceInformationRequest, opts ...grpc.CallOption) (*GetDeviceInformationResponse, error)
	// Get port information about a Port. This should be used to get the full configuration of the port
	// or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 1 min to return, for a quick overview use the BasicPortInformation method
	//   - Basic info with MAC Address
	//   - Configuration
	//   - Statistics
	//   - Transceiver Information
	//   - ACL / QoS
	//   - DHCP Table
	//   - MAC Table
	GetPortInformation(ctx context.Context, in *GetPortInformationRequest, opts ...grpc.CallOption) (*GetPortInformationResponse, error)
	// GetBasicPortInformation returns information about a port on a device. This should only take a few seconds to return
	// so it can be used to get a quick overview of the port. This should not be used to get
	// the full configuration of the port or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 5-10 seconds to return, for a more extensive information use the CollectPortInformation method
	//
	//   - Basic port info
	//
	//   - Statistics
	//
	//   - Transceiver Information (if possible to do quickly)
	//
	//     BasicPortsInformation returns information about all ports on a device. This should only take a few seconds longer
	//     to return.
	GetBasicPortInformation(ctx context.Context, in *GetBasicPortInformationRequest, opts ...grpc.CallOption) (*GetPortInformationResponse, error)
	GetBasicPortsInformation(ctx context.Context, in *GetBasicPortsInformationRequest, opts ...grpc.CallOption) (*GetPortsInformationResponse, error)
	// RunningConfiguration collects the configuration of a network element check for any changes between the stored config and the
	// collected one. Returs a list of changes and the config collected from the network element
	GetRunningConfiguration(ctx context.Context, in *GetRunningConfigurationRequest, opts ...grpc.CallOption) (*GetRunningConfigurationResponse, error)
	GetDeviceNeighbors(ctx context.Context, in *GetDeviceNeighborsRequest, opts ...grpc.CallOption) (*GetDeviceNeighborsResponse, error)
}

type pollerClient struct {
	cc grpc.ClientConnInterface
}

func NewPollerClient(cc grpc.ClientConnInterface) PollerClient {
	return &pollerClient{cc}
}

func (c *pollerClient) RequestTerminal(ctx context.Context, in *RequestTerminalRequest, opts ...grpc.CallOption) (*RequestTerminalResponse, error) {
	out := new(RequestTerminalResponse)
	err := c.cc.Invoke(ctx, Poller_RequestTerminal_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) OpenTerminal(ctx context.Context, opts ...grpc.CallOption) (Poller_OpenTerminalClient, error) {
	stream, err := c.cc.NewStream(ctx, &Poller_ServiceDesc.Streams[0], Poller_OpenTerminal_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &pollerOpenTerminalClient{stream}
	return x, nil
}

type Poller_OpenTerminalClient interface {
	Send(*TerminalInput) error
	Recv() (*TerminalOutput, error)
	grpc.ClientStream
}

type pollerOpenTerminalClient struct {
	grpc.ClientStream
}

func (x *pollerOpenTerminalClient) Send(m *TerminalInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pollerOpenTerminalClient) Recv() (*TerminalOutput, error) {
	m := new(TerminalOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pollerClient) ListTerminals(ctx context.Context, in *ListTerminalsRequest, opts ...grpc.CallOption) (*ListTerminalsResponse, error) {
	out := new(ListTerminalsResponse)
	err := c.cc.Invoke(ctx, Poller_ListTerminals_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) GetTerminal(ctx context.Context, in *GetTerminalRequest, opts ...grpc.CallOption) (*TerminalSession, error) {
	out := new(TerminalSession)
	err := c.cc.Invoke(ctx, Poller_GetTerminal_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) DiscoverDevice(ctx context.Context, in *DiscoverDeviceRequest, opts ...grpc.CallOption) (*DiscoverDeviceResponse, error) {
	out := new(DiscoverDeviceResponse)
	err := c.cc.Invoke(ctx, Poller_DiscoverDevice_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) GetDeviceAvailability(ctx context.Context, in *GetDeviceAvailabilityRequest, opts ...grpc.CallOption) (*GetDeviceAvailabilityResponse, error) {
	out := new(GetDeviceAvailabilityResponse)
	err := c.cc.Invoke(ctx, Poller_GetDeviceAvailability_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) GetDeviceInformation(ctx context.Context, in *GetDeviceInformationRequest, opts ...grpc.CallOption) (*GetDeviceInformationResponse, error) {
	out := new(GetDeviceInformationResponse)
	err := c.cc.Invoke(ctx, Poller_GetDeviceInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) GetBasicDeviceInformation(ctx context.Context, in *GetBasicDeviceInformationRequest, opts ...grpc.CallOption) (*GetDeviceInformationResponse, error) {
	out := new(GetDeviceInformationResponse)
	err := c.cc.Invoke(ctx, Poller_GetBasicDeviceInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) GetPortInformation(ctx context.Context, in *GetPortInformationRequest, opts ...grpc.CallOption) (*GetPortInformationResponse, error) {
	out := new(GetPortInformationResponse)
	err := c.cc.Invoke(ctx, Poller_GetPortInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) GetBasicPortInformation(ctx context.Context, in *GetBasicPortInformationRequest, opts ...grpc.CallOption) (*GetPortInformationResponse, error) {
	out := new(GetPortInformationResponse)
	err := c.cc.Invoke(ctx, Poller_GetBasicPortInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) GetBasicPortsInformation(ctx context.Context, in *GetBasicPortsInformationRequest, opts ...grpc.CallOption) (*GetPortsInformationResponse, error) {
	out := new(GetPortsInformationResponse)
	err := c.cc.Invoke(ctx, Poller_GetBasicPortsInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) GetRunningConfiguration(ctx context.Context, in *GetRunningConfigurationRequest, opts ...grpc.CallOption) (*GetRunningConfigurationResponse, error) {
	out := new(GetRunningConfigurationResponse)
	err := c.cc.Invoke(ctx, Poller_GetRunningConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) GetDeviceNeighbors(ctx context.Context, in *GetDeviceNeighborsRequest, opts ...grpc.CallOption) (*GetDeviceNeighborsResponse, error) {
	out := new(GetDeviceNeighborsResponse)
	err := c.cc.Invoke(ctx, Poller_GetDeviceNeighbors_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PollerServer is the server API for Poller service.
// All implementations should embed UnimplementedPollerServer
// for forward compatibility
type PollerServer interface {
	// RequestTerminal is used to request a terminal on a network element to run commands on the network element
	// it returns a gRRPC stream endpoint that the client to connect to and run commands on the network element
	RequestTerminal(context.Context, *RequestTerminalRequest) (*RequestTerminalResponse, error)
	// open the terminal that was created by the rpc RequestTerminal
	// the terminal is a gRPC stream that the client can connect to and send commands to the network device
	// to connect headers needs to be added to the request
	//   - stream-id: the ID of the created session (returned by the Request Terminal)
	//   - stream-addr: the address of the agent that the Poller needs to connect to
	OpenTerminal(Poller_OpenTerminalServer) error
	// ListTerminals is used to list all terminals that are open at the moment and all terminals that has been opened
	ListTerminals(context.Context, *ListTerminalsRequest) (*ListTerminalsResponse, error)
	// Get a singel temrinal by its ID
	GetTerminal(context.Context, *GetTerminalRequest) (*TerminalSession, error)
	// DiscoverDevice is used to get basic information about an network element, used to make a quick check of the device
	// using the generic resource plugin to make request through resource.GetDeiceInformation
	DiscoverDevice(context.Context, *DiscoverDeviceRequest) (*DiscoverDeviceResponse, error)
	// GetDeviceAvailability is used to check if a network element is available and responding to requests
	// this does not imply that the network element is working correctly or that it is configured correctly but
	// that it is responding to requests and that the poller can connect to it over SNMP/ICMP
	// the availability also verifys checking that hostname is resolvable (if hostname is used in the request)
	GetDeviceAvailability(context.Context, *GetDeviceAvailabilityRequest) (*GetDeviceAvailabilityResponse, error)
	// GetDeviceInformation returns the technical information about a device
	// port etc is not considered in this request
	GetDeviceInformation(context.Context, *GetDeviceInformationRequest) (*GetDeviceInformationResponse, error)
	// get basic information about a device
	// port etc is not considered in this request
	GetBasicDeviceInformation(context.Context, *GetBasicDeviceInformationRequest) (*GetDeviceInformationResponse, error)
	// Get port information about a Port. This should be used to get the full configuration of the port
	// or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 1 min to return, for a quick overview use the BasicPortInformation method
	//   - Basic info with MAC Address
	//   - Configuration
	//   - Statistics
	//   - Transceiver Information
	//   - ACL / QoS
	//   - DHCP Table
	//   - MAC Table
	GetPortInformation(context.Context, *GetPortInformationRequest) (*GetPortInformationResponse, error)
	// GetBasicPortInformation returns information about a port on a device. This should only take a few seconds to return
	// so it can be used to get a quick overview of the port. This should not be used to get
	// the full configuration of the port or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 5-10 seconds to return, for a more extensive information use the CollectPortInformation method
	//
	//   - Basic port info
	//
	//   - Statistics
	//
	//   - Transceiver Information (if possible to do quickly)
	//
	//     BasicPortsInformation returns information about all ports on a device. This should only take a few seconds longer
	//     to return.
	GetBasicPortInformation(context.Context, *GetBasicPortInformationRequest) (*GetPortInformationResponse, error)
	GetBasicPortsInformation(context.Context, *GetBasicPortsInformationRequest) (*GetPortsInformationResponse, error)
	// RunningConfiguration collects the configuration of a network element check for any changes between the stored config and the
	// collected one. Returs a list of changes and the config collected from the network element
	GetRunningConfiguration(context.Context, *GetRunningConfigurationRequest) (*GetRunningConfigurationResponse, error)
	GetDeviceNeighbors(context.Context, *GetDeviceNeighborsRequest) (*GetDeviceNeighborsResponse, error)
}

// UnimplementedPollerServer should be embedded to have forward compatible implementations.
type UnimplementedPollerServer struct {
}

func (UnimplementedPollerServer) RequestTerminal(context.Context, *RequestTerminalRequest) (*RequestTerminalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestTerminal not implemented")
}
func (UnimplementedPollerServer) OpenTerminal(Poller_OpenTerminalServer) error {
	return status.Errorf(codes.Unimplemented, "method OpenTerminal not implemented")
}
func (UnimplementedPollerServer) ListTerminals(context.Context, *ListTerminalsRequest) (*ListTerminalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTerminals not implemented")
}
func (UnimplementedPollerServer) GetTerminal(context.Context, *GetTerminalRequest) (*TerminalSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTerminal not implemented")
}
func (UnimplementedPollerServer) DiscoverDevice(context.Context, *DiscoverDeviceRequest) (*DiscoverDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiscoverDevice not implemented")
}
func (UnimplementedPollerServer) GetDeviceAvailability(context.Context, *GetDeviceAvailabilityRequest) (*GetDeviceAvailabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeviceAvailability not implemented")
}
func (UnimplementedPollerServer) GetDeviceInformation(context.Context, *GetDeviceInformationRequest) (*GetDeviceInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeviceInformation not implemented")
}
func (UnimplementedPollerServer) GetBasicDeviceInformation(context.Context, *GetBasicDeviceInformationRequest) (*GetDeviceInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBasicDeviceInformation not implemented")
}
func (UnimplementedPollerServer) GetPortInformation(context.Context, *GetPortInformationRequest) (*GetPortInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPortInformation not implemented")
}
func (UnimplementedPollerServer) GetBasicPortInformation(context.Context, *GetBasicPortInformationRequest) (*GetPortInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBasicPortInformation not implemented")
}
func (UnimplementedPollerServer) GetBasicPortsInformation(context.Context, *GetBasicPortsInformationRequest) (*GetPortsInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBasicPortsInformation not implemented")
}
func (UnimplementedPollerServer) GetRunningConfiguration(context.Context, *GetRunningConfigurationRequest) (*GetRunningConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRunningConfiguration not implemented")
}
func (UnimplementedPollerServer) GetDeviceNeighbors(context.Context, *GetDeviceNeighborsRequest) (*GetDeviceNeighborsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeviceNeighbors not implemented")
}

// UnsafePollerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PollerServer will
// result in compilation errors.
type UnsafePollerServer interface {
	mustEmbedUnimplementedPollerServer()
}

func RegisterPollerServer(s grpc.ServiceRegistrar, srv PollerServer) {
	s.RegisterService(&Poller_ServiceDesc, srv)
}

func _Poller_RequestTerminal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestTerminalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).RequestTerminal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_RequestTerminal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).RequestTerminal(ctx, req.(*RequestTerminalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_OpenTerminal_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PollerServer).OpenTerminal(&pollerOpenTerminalServer{stream})
}

type Poller_OpenTerminalServer interface {
	Send(*TerminalOutput) error
	Recv() (*TerminalInput, error)
	grpc.ServerStream
}

type pollerOpenTerminalServer struct {
	grpc.ServerStream
}

func (x *pollerOpenTerminalServer) Send(m *TerminalOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pollerOpenTerminalServer) Recv() (*TerminalInput, error) {
	m := new(TerminalInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Poller_ListTerminals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTerminalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).ListTerminals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_ListTerminals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).ListTerminals(ctx, req.(*ListTerminalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_GetTerminal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTerminalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).GetTerminal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_GetTerminal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).GetTerminal(ctx, req.(*GetTerminalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_DiscoverDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).DiscoverDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_DiscoverDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).DiscoverDevice(ctx, req.(*DiscoverDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_GetDeviceAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeviceAvailabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).GetDeviceAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_GetDeviceAvailability_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).GetDeviceAvailability(ctx, req.(*GetDeviceAvailabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_GetDeviceInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeviceInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).GetDeviceInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_GetDeviceInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).GetDeviceInformation(ctx, req.(*GetDeviceInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_GetBasicDeviceInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBasicDeviceInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).GetBasicDeviceInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_GetBasicDeviceInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).GetBasicDeviceInformation(ctx, req.(*GetBasicDeviceInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_GetPortInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPortInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).GetPortInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_GetPortInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).GetPortInformation(ctx, req.(*GetPortInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_GetBasicPortInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBasicPortInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).GetBasicPortInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_GetBasicPortInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).GetBasicPortInformation(ctx, req.(*GetBasicPortInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_GetBasicPortsInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBasicPortsInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).GetBasicPortsInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_GetBasicPortsInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).GetBasicPortsInformation(ctx, req.(*GetBasicPortsInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_GetRunningConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunningConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).GetRunningConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_GetRunningConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).GetRunningConfiguration(ctx, req.(*GetRunningConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_GetDeviceNeighbors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeviceNeighborsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).GetDeviceNeighbors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_GetDeviceNeighbors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).GetDeviceNeighbors(ctx, req.(*GetDeviceNeighborsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Poller_ServiceDesc is the grpc.ServiceDesc for Poller service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Poller_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Poller",
	HandlerType: (*PollerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestTerminal",
			Handler:    _Poller_RequestTerminal_Handler,
		},
		{
			MethodName: "ListTerminals",
			Handler:    _Poller_ListTerminals_Handler,
		},
		{
			MethodName: "GetTerminal",
			Handler:    _Poller_GetTerminal_Handler,
		},
		{
			MethodName: "DiscoverDevice",
			Handler:    _Poller_DiscoverDevice_Handler,
		},
		{
			MethodName: "GetDeviceAvailability",
			Handler:    _Poller_GetDeviceAvailability_Handler,
		},
		{
			MethodName: "GetDeviceInformation",
			Handler:    _Poller_GetDeviceInformation_Handler,
		},
		{
			MethodName: "GetBasicDeviceInformation",
			Handler:    _Poller_GetBasicDeviceInformation_Handler,
		},
		{
			MethodName: "GetPortInformation",
			Handler:    _Poller_GetPortInformation_Handler,
		},
		{
			MethodName: "GetBasicPortInformation",
			Handler:    _Poller_GetBasicPortInformation_Handler,
		},
		{
			MethodName: "GetBasicPortsInformation",
			Handler:    _Poller_GetBasicPortsInformation_Handler,
		},
		{
			MethodName: "GetRunningConfiguration",
			Handler:    _Poller_GetRunningConfiguration_Handler,
		},
		{
			MethodName: "GetDeviceNeighbors",
			Handler:    _Poller_GetDeviceNeighbors_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenTerminal",
			Handler:       _Poller_OpenTerminal_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "core.proto",
}

const (
	Commander_ConfigureStanza_FullMethodName = "/core.Commander/ConfigureStanza"
)

// CommanderClient is the client API for Commander service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommanderClient interface {
	// configure a configuration stanza on a network element
	ConfigureStanza(ctx context.Context, in *ConfigureStanzaRequest, opts ...grpc.CallOption) (*stanzapb.ConfigureResponse, error)
}

type commanderClient struct {
	cc grpc.ClientConnInterface
}

func NewCommanderClient(cc grpc.ClientConnInterface) CommanderClient {
	return &commanderClient{cc}
}

func (c *commanderClient) ConfigureStanza(ctx context.Context, in *ConfigureStanzaRequest, opts ...grpc.CallOption) (*stanzapb.ConfigureResponse, error) {
	out := new(stanzapb.ConfigureResponse)
	err := c.cc.Invoke(ctx, Commander_ConfigureStanza_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommanderServer is the server API for Commander service.
// All implementations should embed UnimplementedCommanderServer
// for forward compatibility
type CommanderServer interface {
	// configure a configuration stanza on a network element
	ConfigureStanza(context.Context, *ConfigureStanzaRequest) (*stanzapb.ConfigureResponse, error)
}

// UnimplementedCommanderServer should be embedded to have forward compatible implementations.
type UnimplementedCommanderServer struct {
}

func (UnimplementedCommanderServer) ConfigureStanza(context.Context, *ConfigureStanzaRequest) (*stanzapb.ConfigureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureStanza not implemented")
}

// UnsafeCommanderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommanderServer will
// result in compilation errors.
type UnsafeCommanderServer interface {
	mustEmbedUnimplementedCommanderServer()
}

func RegisterCommanderServer(s grpc.ServiceRegistrar, srv CommanderServer) {
	s.RegisterService(&Commander_ServiceDesc, srv)
}

func _Commander_ConfigureStanza_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureStanzaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommanderServer).ConfigureStanza(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Commander_ConfigureStanza_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommanderServer).ConfigureStanza(ctx, req.(*ConfigureStanzaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Commander_ServiceDesc is the grpc.ServiceDesc for Commander service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Commander_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Commander",
	HandlerType: (*CommanderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigureStanza",
			Handler:    _Commander_ConfigureStanza_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

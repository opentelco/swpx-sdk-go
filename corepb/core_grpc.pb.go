//
// Copyright (c) 2023. Liero AB
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.26.1
// source: core.proto

package corepb

import (
	context "context"
	analysispb "go.opentelco.io/swpx-sdk-go/analysispb"
	stanzapb "go.opentelco.io/swpx-sdk-go/stanzapb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Plugins_List_FullMethodName = "/core.Plugins/List"
)

// PluginsClient is the client API for Plugins service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginsClient interface {
	// GetPlugins returns a list of all plugins that are available in the system
	List(ctx context.Context, in *ListPluginsRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error)
}

type pluginsClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginsClient(cc grpc.ClientConnInterface) PluginsClient {
	return &pluginsClient{cc}
}

func (c *pluginsClient) List(ctx context.Context, in *ListPluginsRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error) {
	out := new(ListPluginsResponse)
	err := c.cc.Invoke(ctx, Plugins_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginsServer is the server API for Plugins service.
// All implementations should embed UnimplementedPluginsServer
// for forward compatibility
type PluginsServer interface {
	// GetPlugins returns a list of all plugins that are available in the system
	List(context.Context, *ListPluginsRequest) (*ListPluginsResponse, error)
}

// UnimplementedPluginsServer should be embedded to have forward compatible implementations.
type UnimplementedPluginsServer struct {
}

func (UnimplementedPluginsServer) List(context.Context, *ListPluginsRequest) (*ListPluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafePluginsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginsServer will
// result in compilation errors.
type UnsafePluginsServer interface {
	mustEmbedUnimplementedPluginsServer()
}

func RegisterPluginsServer(s grpc.ServiceRegistrar, srv PluginsServer) {
	s.RegisterService(&Plugins_ServiceDesc, srv)
}

func _Plugins_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPluginsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Plugins_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginsServer).List(ctx, req.(*ListPluginsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Plugins_ServiceDesc is the grpc.ServiceDesc for Plugins service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Plugins_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Plugins",
	HandlerType: (*PluginsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Plugins_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

const (
	Signatures_Collect_FullMethodName          = "/core.Signatures/Collect"
	Signatures_GetCollections_FullMethodName   = "/core.Signatures/GetCollections"
	Signatures_GetCollection_FullMethodName    = "/core.Signatures/GetCollection"
	Signatures_UploadCollection_FullMethodName = "/core.Signatures/UploadCollection"
	Signatures_RemoveCollection_FullMethodName = "/core.Signatures/RemoveCollection"
	Signatures_Compare_FullMethodName          = "/core.Signatures/Compare"
)

// SignaturesClient is the client API for Signatures service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SignaturesClient interface {
	// Collecti s used to collect the signatures of all ports on a device
	// or a specific port on the device.
	//   - DHCP Table & MAC Table
	//   - Port Link Status
	//   - SFP Transceiver Information
	Collect(ctx context.Context, in *CollectSignaturesRequest, opts ...grpc.CallOption) (*CollectSignaturesResponse, error)
	// GetCollections returns a list of all collections that has been collected, the list can be filtered
	// by device, regions, timestamp etc. The list only contains a sumary of the collection and not the
	// full collection. To get the full collection use the GetCollection method
	GetCollections(ctx context.Context, in *GetCollectionsRequest, opts ...grpc.CallOption) (*GetCollectionsResponse, error)
	// GetCollection returns a single collection that has been collected, the collection contains all the data that was collected from the device
	GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*GetCollectionResponse, error)
	// UploadCollection is used to upload a collection to the database and store it for later use
	UploadCollection(ctx context.Context, in *UploadCollectionRequest, opts ...grpc.CallOption) (*UploadCollectionResponse, error)
	// RemoveCollection is used to remove a collection from the database
	RemoveCollection(ctx context.Context, in *RemoveCollectionRequest, opts ...grpc.CallOption) (*RemoveCollectionResponse, error)
	// Compare is used to compare 1-n signature collections with 1-n signature collections
	// The previous 1-n collections are merged together to create a baseline of how the
	// device looked before the change. Port status will be taken from the last collection
	// and the rest of the data will be taken from the merged collection. The new 1-n collections
	// will be compared to the baseline and the differences will be returned to the client.
	Compare(ctx context.Context, in *CompareRequest, opts ...grpc.CallOption) (*CompareResponse, error)
}

type signaturesClient struct {
	cc grpc.ClientConnInterface
}

func NewSignaturesClient(cc grpc.ClientConnInterface) SignaturesClient {
	return &signaturesClient{cc}
}

func (c *signaturesClient) Collect(ctx context.Context, in *CollectSignaturesRequest, opts ...grpc.CallOption) (*CollectSignaturesResponse, error) {
	out := new(CollectSignaturesResponse)
	err := c.cc.Invoke(ctx, Signatures_Collect_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signaturesClient) GetCollections(ctx context.Context, in *GetCollectionsRequest, opts ...grpc.CallOption) (*GetCollectionsResponse, error) {
	out := new(GetCollectionsResponse)
	err := c.cc.Invoke(ctx, Signatures_GetCollections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signaturesClient) GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*GetCollectionResponse, error) {
	out := new(GetCollectionResponse)
	err := c.cc.Invoke(ctx, Signatures_GetCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signaturesClient) UploadCollection(ctx context.Context, in *UploadCollectionRequest, opts ...grpc.CallOption) (*UploadCollectionResponse, error) {
	out := new(UploadCollectionResponse)
	err := c.cc.Invoke(ctx, Signatures_UploadCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signaturesClient) RemoveCollection(ctx context.Context, in *RemoveCollectionRequest, opts ...grpc.CallOption) (*RemoveCollectionResponse, error) {
	out := new(RemoveCollectionResponse)
	err := c.cc.Invoke(ctx, Signatures_RemoveCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signaturesClient) Compare(ctx context.Context, in *CompareRequest, opts ...grpc.CallOption) (*CompareResponse, error) {
	out := new(CompareResponse)
	err := c.cc.Invoke(ctx, Signatures_Compare_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SignaturesServer is the server API for Signatures service.
// All implementations should embed UnimplementedSignaturesServer
// for forward compatibility
type SignaturesServer interface {
	// Collecti s used to collect the signatures of all ports on a device
	// or a specific port on the device.
	//   - DHCP Table & MAC Table
	//   - Port Link Status
	//   - SFP Transceiver Information
	Collect(context.Context, *CollectSignaturesRequest) (*CollectSignaturesResponse, error)
	// GetCollections returns a list of all collections that has been collected, the list can be filtered
	// by device, regions, timestamp etc. The list only contains a sumary of the collection and not the
	// full collection. To get the full collection use the GetCollection method
	GetCollections(context.Context, *GetCollectionsRequest) (*GetCollectionsResponse, error)
	// GetCollection returns a single collection that has been collected, the collection contains all the data that was collected from the device
	GetCollection(context.Context, *GetCollectionRequest) (*GetCollectionResponse, error)
	// UploadCollection is used to upload a collection to the database and store it for later use
	UploadCollection(context.Context, *UploadCollectionRequest) (*UploadCollectionResponse, error)
	// RemoveCollection is used to remove a collection from the database
	RemoveCollection(context.Context, *RemoveCollectionRequest) (*RemoveCollectionResponse, error)
	// Compare is used to compare 1-n signature collections with 1-n signature collections
	// The previous 1-n collections are merged together to create a baseline of how the
	// device looked before the change. Port status will be taken from the last collection
	// and the rest of the data will be taken from the merged collection. The new 1-n collections
	// will be compared to the baseline and the differences will be returned to the client.
	Compare(context.Context, *CompareRequest) (*CompareResponse, error)
}

// UnimplementedSignaturesServer should be embedded to have forward compatible implementations.
type UnimplementedSignaturesServer struct {
}

func (UnimplementedSignaturesServer) Collect(context.Context, *CollectSignaturesRequest) (*CollectSignaturesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Collect not implemented")
}
func (UnimplementedSignaturesServer) GetCollections(context.Context, *GetCollectionsRequest) (*GetCollectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCollections not implemented")
}
func (UnimplementedSignaturesServer) GetCollection(context.Context, *GetCollectionRequest) (*GetCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCollection not implemented")
}
func (UnimplementedSignaturesServer) UploadCollection(context.Context, *UploadCollectionRequest) (*UploadCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadCollection not implemented")
}
func (UnimplementedSignaturesServer) RemoveCollection(context.Context, *RemoveCollectionRequest) (*RemoveCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCollection not implemented")
}
func (UnimplementedSignaturesServer) Compare(context.Context, *CompareRequest) (*CompareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Compare not implemented")
}

// UnsafeSignaturesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SignaturesServer will
// result in compilation errors.
type UnsafeSignaturesServer interface {
	mustEmbedUnimplementedSignaturesServer()
}

func RegisterSignaturesServer(s grpc.ServiceRegistrar, srv SignaturesServer) {
	s.RegisterService(&Signatures_ServiceDesc, srv)
}

func _Signatures_Collect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectSignaturesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).Collect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_Collect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).Collect(ctx, req.(*CollectSignaturesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signatures_GetCollections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).GetCollections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_GetCollections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).GetCollections(ctx, req.(*GetCollectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signatures_GetCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).GetCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_GetCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).GetCollection(ctx, req.(*GetCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signatures_UploadCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).UploadCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_UploadCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).UploadCollection(ctx, req.(*UploadCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signatures_RemoveCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).RemoveCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_RemoveCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).RemoveCollection(ctx, req.(*RemoveCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signatures_Compare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignaturesServer).Compare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signatures_Compare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignaturesServer).Compare(ctx, req.(*CompareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Signatures_ServiceDesc is the grpc.ServiceDesc for Signatures service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Signatures_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Signatures",
	HandlerType: (*SignaturesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Collect",
			Handler:    _Signatures_Collect_Handler,
		},
		{
			MethodName: "GetCollections",
			Handler:    _Signatures_GetCollections_Handler,
		},
		{
			MethodName: "GetCollection",
			Handler:    _Signatures_GetCollection_Handler,
		},
		{
			MethodName: "UploadCollection",
			Handler:    _Signatures_UploadCollection_Handler,
		},
		{
			MethodName: "RemoveCollection",
			Handler:    _Signatures_RemoveCollection_Handler,
		},
		{
			MethodName: "Compare",
			Handler:    _Signatures_Compare_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

const (
	Diagnostics_RunDiagnostic_FullMethodName      = "/core.Diagnostics/RunDiagnostic"
	Diagnostics_RunQuickDiagnostic_FullMethodName = "/core.Diagnostics/RunQuickDiagnostic"
	Diagnostics_GetDiagnostic_FullMethodName      = "/core.Diagnostics/GetDiagnostic"
	Diagnostics_ListDiagnostics_FullMethodName    = "/core.Diagnostics/ListDiagnostics"
)

// DiagnosticsClient is the client API for Diagnostics service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DiagnosticsClient interface {
	// RunDiagnostic is used to run a diagnostic on a network element or a specific port on the network element
	// It will collect data from the network element and then wait for a period of time and collect data again
	// and return the difference between the two collections of data to the client. The data will also be analyzed
	// by the poller and Report of the diagnostic will be returned to the client.
	// the diagnostic will be run the number of times specified in the request and the time between each poll is 10 seconds.
	// connecting to a device can take up to one minute depending on the device and protocol used so a standard diagnostic
	// will take aproximately 1 minute to complete.
	RunDiagnostic(ctx context.Context, in *RunDiagnosticRequest, opts ...grpc.CallOption) (*RunDiagnosticResponse, error)
	// Run a diagnostic but a quick diagnostic. This will only collect data from the network element once and then return
	RunQuickDiagnostic(ctx context.Context, in *RunQuickDiagnosticRequest, opts ...grpc.CallOption) (*RunQuickDiagnosticResponse, error)
	// GetDiagnostic returns the report of a diagnostic that has been run on a network element or a specific port on the network element
	GetDiagnostic(ctx context.Context, in *GetDiagnosticRequest, opts ...grpc.CallOption) (*analysispb.Report, error)
	// ListDiagnostics returns a list of diagnostics that has been run on a network element or a specific port on the network element
	ListDiagnostics(ctx context.Context, in *ListDiagnosticsRequest, opts ...grpc.CallOption) (*ListDiagnosticsResponse, error)
}

type diagnosticsClient struct {
	cc grpc.ClientConnInterface
}

func NewDiagnosticsClient(cc grpc.ClientConnInterface) DiagnosticsClient {
	return &diagnosticsClient{cc}
}

func (c *diagnosticsClient) RunDiagnostic(ctx context.Context, in *RunDiagnosticRequest, opts ...grpc.CallOption) (*RunDiagnosticResponse, error) {
	out := new(RunDiagnosticResponse)
	err := c.cc.Invoke(ctx, Diagnostics_RunDiagnostic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsClient) RunQuickDiagnostic(ctx context.Context, in *RunQuickDiagnosticRequest, opts ...grpc.CallOption) (*RunQuickDiagnosticResponse, error) {
	out := new(RunQuickDiagnosticResponse)
	err := c.cc.Invoke(ctx, Diagnostics_RunQuickDiagnostic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsClient) GetDiagnostic(ctx context.Context, in *GetDiagnosticRequest, opts ...grpc.CallOption) (*analysispb.Report, error) {
	out := new(analysispb.Report)
	err := c.cc.Invoke(ctx, Diagnostics_GetDiagnostic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsClient) ListDiagnostics(ctx context.Context, in *ListDiagnosticsRequest, opts ...grpc.CallOption) (*ListDiagnosticsResponse, error) {
	out := new(ListDiagnosticsResponse)
	err := c.cc.Invoke(ctx, Diagnostics_ListDiagnostics_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiagnosticsServer is the server API for Diagnostics service.
// All implementations should embed UnimplementedDiagnosticsServer
// for forward compatibility
type DiagnosticsServer interface {
	// RunDiagnostic is used to run a diagnostic on a network element or a specific port on the network element
	// It will collect data from the network element and then wait for a period of time and collect data again
	// and return the difference between the two collections of data to the client. The data will also be analyzed
	// by the poller and Report of the diagnostic will be returned to the client.
	// the diagnostic will be run the number of times specified in the request and the time between each poll is 10 seconds.
	// connecting to a device can take up to one minute depending on the device and protocol used so a standard diagnostic
	// will take aproximately 1 minute to complete.
	RunDiagnostic(context.Context, *RunDiagnosticRequest) (*RunDiagnosticResponse, error)
	// Run a diagnostic but a quick diagnostic. This will only collect data from the network element once and then return
	RunQuickDiagnostic(context.Context, *RunQuickDiagnosticRequest) (*RunQuickDiagnosticResponse, error)
	// GetDiagnostic returns the report of a diagnostic that has been run on a network element or a specific port on the network element
	GetDiagnostic(context.Context, *GetDiagnosticRequest) (*analysispb.Report, error)
	// ListDiagnostics returns a list of diagnostics that has been run on a network element or a specific port on the network element
	ListDiagnostics(context.Context, *ListDiagnosticsRequest) (*ListDiagnosticsResponse, error)
}

// UnimplementedDiagnosticsServer should be embedded to have forward compatible implementations.
type UnimplementedDiagnosticsServer struct {
}

func (UnimplementedDiagnosticsServer) RunDiagnostic(context.Context, *RunDiagnosticRequest) (*RunDiagnosticResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunDiagnostic not implemented")
}
func (UnimplementedDiagnosticsServer) RunQuickDiagnostic(context.Context, *RunQuickDiagnosticRequest) (*RunQuickDiagnosticResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunQuickDiagnostic not implemented")
}
func (UnimplementedDiagnosticsServer) GetDiagnostic(context.Context, *GetDiagnosticRequest) (*analysispb.Report, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDiagnostic not implemented")
}
func (UnimplementedDiagnosticsServer) ListDiagnostics(context.Context, *ListDiagnosticsRequest) (*ListDiagnosticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDiagnostics not implemented")
}

// UnsafeDiagnosticsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DiagnosticsServer will
// result in compilation errors.
type UnsafeDiagnosticsServer interface {
	mustEmbedUnimplementedDiagnosticsServer()
}

func RegisterDiagnosticsServer(s grpc.ServiceRegistrar, srv DiagnosticsServer) {
	s.RegisterService(&Diagnostics_ServiceDesc, srv)
}

func _Diagnostics_RunDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunDiagnosticRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).RunDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_RunDiagnostic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).RunDiagnostic(ctx, req.(*RunDiagnosticRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnostics_RunQuickDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunQuickDiagnosticRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).RunQuickDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_RunQuickDiagnostic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).RunQuickDiagnostic(ctx, req.(*RunQuickDiagnosticRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnostics_GetDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiagnosticRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).GetDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_GetDiagnostic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).GetDiagnostic(ctx, req.(*GetDiagnosticRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnostics_ListDiagnostics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDiagnosticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsServer).ListDiagnostics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Diagnostics_ListDiagnostics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsServer).ListDiagnostics(ctx, req.(*ListDiagnosticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Diagnostics_ServiceDesc is the grpc.ServiceDesc for Diagnostics service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Diagnostics_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Diagnostics",
	HandlerType: (*DiagnosticsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunDiagnostic",
			Handler:    _Diagnostics_RunDiagnostic_Handler,
		},
		{
			MethodName: "RunQuickDiagnostic",
			Handler:    _Diagnostics_RunQuickDiagnostic_Handler,
		},
		{
			MethodName: "GetDiagnostic",
			Handler:    _Diagnostics_GetDiagnostic_Handler,
		},
		{
			MethodName: "ListDiagnostics",
			Handler:    _Diagnostics_ListDiagnostics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

const (
	Poller_RequestTerminal_FullMethodName               = "/core.Poller/RequestTerminal"
	Poller_OpenTerminal_FullMethodName                  = "/core.Poller/OpenTerminal"
	Poller_ListTerminals_FullMethodName                 = "/core.Poller/ListTerminals"
	Poller_GetTerminal_FullMethodName                   = "/core.Poller/GetTerminal"
	Poller_Discover_FullMethodName                      = "/core.Poller/Discover"
	Poller_CheckAvailability_FullMethodName             = "/core.Poller/CheckAvailability"
	Poller_CollectDeviceInformation_FullMethodName      = "/core.Poller/CollectDeviceInformation"
	Poller_CollectBasicDeviceInformation_FullMethodName = "/core.Poller/CollectBasicDeviceInformation"
	Poller_CollectPortInformation_FullMethodName        = "/core.Poller/CollectPortInformation"
	Poller_CollectBasicPortInformation_FullMethodName   = "/core.Poller/CollectBasicPortInformation"
	Poller_CollectConfig_FullMethodName                 = "/core.Poller/CollectConfig"
	Poller_CollectNeighbours_FullMethodName             = "/core.Poller/CollectNeighbours"
)

// PollerClient is the client API for Poller service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PollerClient interface {
	// RequestTerminal is used to request a terminal on a network element to run commands on the network element
	// it returns a gRRPC stream endpoint that the client to connect to and run commands on the network element
	RequestTerminal(ctx context.Context, in *RequestTerminalRequest, opts ...grpc.CallOption) (*RequestTerminalResponse, error)
	// open the terminal that was created by the rpc RequestTerminal
	// the terminal is a gRPC stream that the client can connect to and send commands to the network device
	// to connect headers needs to be added to the request
	//   - stream-id: the ID of the created session (returned by the Request Terminal)
	//   - stream-addr: the address of the agent that the Poller needs to connect to
	OpenTerminal(ctx context.Context, opts ...grpc.CallOption) (Poller_OpenTerminalClient, error)
	// ListTerminals is used to list all terminals that are open at the moment and all terminals that has been opened
	ListTerminals(ctx context.Context, in *ListTerminalsRequest, opts ...grpc.CallOption) (*ListTerminalsResponse, error)
	// Get a singel temrinal by its ID
	GetTerminal(ctx context.Context, in *GetTerminalRequest, opts ...grpc.CallOption) (*TerminalSession, error)
	// Discover is used to get basic information about an network element, used to make a quick check of the device
	// using the generic resource plugin to make request through resource.GetDeiceInformation
	Discover(ctx context.Context, in *DiscoverRequest, opts ...grpc.CallOption) (*DiscoverResponse, error)
	// CheckAvailability is used to check if a network element is available and responding to requests
	// this does not imply that the network element is working correctly or that it is configured correctly but
	// that it is responding to requests and that the poller can connect to it over SNMP/ICMP
	// the availability also verifys checking that hostname is resolvable (if hostname is used in the request)
	CheckAvailability(ctx context.Context, in *CheckAvailabilityRequest, opts ...grpc.CallOption) (*CheckAvailabilityResponse, error)
	// GetDeviceInformation returns the technical information about a device
	// port etc is not considered in this request
	CollectDeviceInformation(ctx context.Context, in *CollectDeviceInformationRequest, opts ...grpc.CallOption) (*DeviceInformationResponse, error)
	// get basic information about a device
	// port etc is not considered in this request
	CollectBasicDeviceInformation(ctx context.Context, in *CollectBasicDeviceInformationRequest, opts ...grpc.CallOption) (*DeviceInformationResponse, error)
	// Get port information about a Port. This should be used to get the full configuration of the port
	// or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 1 min to return, for a quick overview use the BasicPortInformation method
	//   - Basic info with MAC Address
	//   - Configuration
	//   - Statistics
	//   - Transceiver Information
	//   - ACL / QoS
	//   - DHCP Table
	//   - MAC Table
	CollectPortInformation(ctx context.Context, in *CollectPortInformationRequest, opts ...grpc.CallOption) (*PortInformationResponse, error)
	// CollectBasicPortInformation returns information about a port on a device. This should only take a few seconds to return
	// so it can be used to get a quick overview of the port. This should not be used to get
	// the full configuration of the port or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 5-10 seconds to return, for a more extensive information use the CollectPortInformation method
	//   - Basic info with MAC Address
	//   - Statistics
	//   - Transceiver Information (if possible to do quickly)
	CollectBasicPortInformation(ctx context.Context, in *CollectBasicPortInformationRequest, opts ...grpc.CallOption) (*PortInformationResponse, error)
	// CollectConfig collects the configuration of a network element check for any changes between the stored config and the
	// collected one. Returs a list of changes and the config collected from the network element
	CollectConfig(ctx context.Context, in *CollectConfigRequest, opts ...grpc.CallOption) (*CollectConfigResponse, error)
	CollectNeighbours(ctx context.Context, in *CollectNeighboursRequest, opts ...grpc.CallOption) (*CollectNeighboursResponse, error)
}

type pollerClient struct {
	cc grpc.ClientConnInterface
}

func NewPollerClient(cc grpc.ClientConnInterface) PollerClient {
	return &pollerClient{cc}
}

func (c *pollerClient) RequestTerminal(ctx context.Context, in *RequestTerminalRequest, opts ...grpc.CallOption) (*RequestTerminalResponse, error) {
	out := new(RequestTerminalResponse)
	err := c.cc.Invoke(ctx, Poller_RequestTerminal_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) OpenTerminal(ctx context.Context, opts ...grpc.CallOption) (Poller_OpenTerminalClient, error) {
	stream, err := c.cc.NewStream(ctx, &Poller_ServiceDesc.Streams[0], Poller_OpenTerminal_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &pollerOpenTerminalClient{stream}
	return x, nil
}

type Poller_OpenTerminalClient interface {
	Send(*TerminalInput) error
	Recv() (*TerminalOutput, error)
	grpc.ClientStream
}

type pollerOpenTerminalClient struct {
	grpc.ClientStream
}

func (x *pollerOpenTerminalClient) Send(m *TerminalInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pollerOpenTerminalClient) Recv() (*TerminalOutput, error) {
	m := new(TerminalOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pollerClient) ListTerminals(ctx context.Context, in *ListTerminalsRequest, opts ...grpc.CallOption) (*ListTerminalsResponse, error) {
	out := new(ListTerminalsResponse)
	err := c.cc.Invoke(ctx, Poller_ListTerminals_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) GetTerminal(ctx context.Context, in *GetTerminalRequest, opts ...grpc.CallOption) (*TerminalSession, error) {
	out := new(TerminalSession)
	err := c.cc.Invoke(ctx, Poller_GetTerminal_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) Discover(ctx context.Context, in *DiscoverRequest, opts ...grpc.CallOption) (*DiscoverResponse, error) {
	out := new(DiscoverResponse)
	err := c.cc.Invoke(ctx, Poller_Discover_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CheckAvailability(ctx context.Context, in *CheckAvailabilityRequest, opts ...grpc.CallOption) (*CheckAvailabilityResponse, error) {
	out := new(CheckAvailabilityResponse)
	err := c.cc.Invoke(ctx, Poller_CheckAvailability_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CollectDeviceInformation(ctx context.Context, in *CollectDeviceInformationRequest, opts ...grpc.CallOption) (*DeviceInformationResponse, error) {
	out := new(DeviceInformationResponse)
	err := c.cc.Invoke(ctx, Poller_CollectDeviceInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CollectBasicDeviceInformation(ctx context.Context, in *CollectBasicDeviceInformationRequest, opts ...grpc.CallOption) (*DeviceInformationResponse, error) {
	out := new(DeviceInformationResponse)
	err := c.cc.Invoke(ctx, Poller_CollectBasicDeviceInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CollectPortInformation(ctx context.Context, in *CollectPortInformationRequest, opts ...grpc.CallOption) (*PortInformationResponse, error) {
	out := new(PortInformationResponse)
	err := c.cc.Invoke(ctx, Poller_CollectPortInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CollectBasicPortInformation(ctx context.Context, in *CollectBasicPortInformationRequest, opts ...grpc.CallOption) (*PortInformationResponse, error) {
	out := new(PortInformationResponse)
	err := c.cc.Invoke(ctx, Poller_CollectBasicPortInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CollectConfig(ctx context.Context, in *CollectConfigRequest, opts ...grpc.CallOption) (*CollectConfigResponse, error) {
	out := new(CollectConfigResponse)
	err := c.cc.Invoke(ctx, Poller_CollectConfig_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pollerClient) CollectNeighbours(ctx context.Context, in *CollectNeighboursRequest, opts ...grpc.CallOption) (*CollectNeighboursResponse, error) {
	out := new(CollectNeighboursResponse)
	err := c.cc.Invoke(ctx, Poller_CollectNeighbours_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PollerServer is the server API for Poller service.
// All implementations should embed UnimplementedPollerServer
// for forward compatibility
type PollerServer interface {
	// RequestTerminal is used to request a terminal on a network element to run commands on the network element
	// it returns a gRRPC stream endpoint that the client to connect to and run commands on the network element
	RequestTerminal(context.Context, *RequestTerminalRequest) (*RequestTerminalResponse, error)
	// open the terminal that was created by the rpc RequestTerminal
	// the terminal is a gRPC stream that the client can connect to and send commands to the network device
	// to connect headers needs to be added to the request
	//   - stream-id: the ID of the created session (returned by the Request Terminal)
	//   - stream-addr: the address of the agent that the Poller needs to connect to
	OpenTerminal(Poller_OpenTerminalServer) error
	// ListTerminals is used to list all terminals that are open at the moment and all terminals that has been opened
	ListTerminals(context.Context, *ListTerminalsRequest) (*ListTerminalsResponse, error)
	// Get a singel temrinal by its ID
	GetTerminal(context.Context, *GetTerminalRequest) (*TerminalSession, error)
	// Discover is used to get basic information about an network element, used to make a quick check of the device
	// using the generic resource plugin to make request through resource.GetDeiceInformation
	Discover(context.Context, *DiscoverRequest) (*DiscoverResponse, error)
	// CheckAvailability is used to check if a network element is available and responding to requests
	// this does not imply that the network element is working correctly or that it is configured correctly but
	// that it is responding to requests and that the poller can connect to it over SNMP/ICMP
	// the availability also verifys checking that hostname is resolvable (if hostname is used in the request)
	CheckAvailability(context.Context, *CheckAvailabilityRequest) (*CheckAvailabilityResponse, error)
	// GetDeviceInformation returns the technical information about a device
	// port etc is not considered in this request
	CollectDeviceInformation(context.Context, *CollectDeviceInformationRequest) (*DeviceInformationResponse, error)
	// get basic information about a device
	// port etc is not considered in this request
	CollectBasicDeviceInformation(context.Context, *CollectBasicDeviceInformationRequest) (*DeviceInformationResponse, error)
	// Get port information about a Port. This should be used to get the full configuration of the port
	// or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 1 min to return, for a quick overview use the BasicPortInformation method
	//   - Basic info with MAC Address
	//   - Configuration
	//   - Statistics
	//   - Transceiver Information
	//   - ACL / QoS
	//   - DHCP Table
	//   - MAC Table
	CollectPortInformation(context.Context, *CollectPortInformationRequest) (*PortInformationResponse, error)
	// CollectBasicPortInformation returns information about a port on a device. This should only take a few seconds to return
	// so it can be used to get a quick overview of the port. This should not be used to get
	// the full configuration of the port or logging in thourgh ssh/telnet and running commands
	//
	// The request should contain the hostname and the port name
	// together with the ifIndex and the physical index of the port
	// Max 5-10 seconds to return, for a more extensive information use the CollectPortInformation method
	//   - Basic info with MAC Address
	//   - Statistics
	//   - Transceiver Information (if possible to do quickly)
	CollectBasicPortInformation(context.Context, *CollectBasicPortInformationRequest) (*PortInformationResponse, error)
	// CollectConfig collects the configuration of a network element check for any changes between the stored config and the
	// collected one. Returs a list of changes and the config collected from the network element
	CollectConfig(context.Context, *CollectConfigRequest) (*CollectConfigResponse, error)
	CollectNeighbours(context.Context, *CollectNeighboursRequest) (*CollectNeighboursResponse, error)
}

// UnimplementedPollerServer should be embedded to have forward compatible implementations.
type UnimplementedPollerServer struct {
}

func (UnimplementedPollerServer) RequestTerminal(context.Context, *RequestTerminalRequest) (*RequestTerminalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestTerminal not implemented")
}
func (UnimplementedPollerServer) OpenTerminal(Poller_OpenTerminalServer) error {
	return status.Errorf(codes.Unimplemented, "method OpenTerminal not implemented")
}
func (UnimplementedPollerServer) ListTerminals(context.Context, *ListTerminalsRequest) (*ListTerminalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTerminals not implemented")
}
func (UnimplementedPollerServer) GetTerminal(context.Context, *GetTerminalRequest) (*TerminalSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTerminal not implemented")
}
func (UnimplementedPollerServer) Discover(context.Context, *DiscoverRequest) (*DiscoverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Discover not implemented")
}
func (UnimplementedPollerServer) CheckAvailability(context.Context, *CheckAvailabilityRequest) (*CheckAvailabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckAvailability not implemented")
}
func (UnimplementedPollerServer) CollectDeviceInformation(context.Context, *CollectDeviceInformationRequest) (*DeviceInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectDeviceInformation not implemented")
}
func (UnimplementedPollerServer) CollectBasicDeviceInformation(context.Context, *CollectBasicDeviceInformationRequest) (*DeviceInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectBasicDeviceInformation not implemented")
}
func (UnimplementedPollerServer) CollectPortInformation(context.Context, *CollectPortInformationRequest) (*PortInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectPortInformation not implemented")
}
func (UnimplementedPollerServer) CollectBasicPortInformation(context.Context, *CollectBasicPortInformationRequest) (*PortInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectBasicPortInformation not implemented")
}
func (UnimplementedPollerServer) CollectConfig(context.Context, *CollectConfigRequest) (*CollectConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectConfig not implemented")
}
func (UnimplementedPollerServer) CollectNeighbours(context.Context, *CollectNeighboursRequest) (*CollectNeighboursResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectNeighbours not implemented")
}

// UnsafePollerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PollerServer will
// result in compilation errors.
type UnsafePollerServer interface {
	mustEmbedUnimplementedPollerServer()
}

func RegisterPollerServer(s grpc.ServiceRegistrar, srv PollerServer) {
	s.RegisterService(&Poller_ServiceDesc, srv)
}

func _Poller_RequestTerminal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestTerminalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).RequestTerminal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_RequestTerminal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).RequestTerminal(ctx, req.(*RequestTerminalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_OpenTerminal_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PollerServer).OpenTerminal(&pollerOpenTerminalServer{stream})
}

type Poller_OpenTerminalServer interface {
	Send(*TerminalOutput) error
	Recv() (*TerminalInput, error)
	grpc.ServerStream
}

type pollerOpenTerminalServer struct {
	grpc.ServerStream
}

func (x *pollerOpenTerminalServer) Send(m *TerminalOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pollerOpenTerminalServer) Recv() (*TerminalInput, error) {
	m := new(TerminalInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Poller_ListTerminals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTerminalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).ListTerminals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_ListTerminals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).ListTerminals(ctx, req.(*ListTerminalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_GetTerminal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTerminalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).GetTerminal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_GetTerminal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).GetTerminal(ctx, req.(*GetTerminalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_Discover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).Discover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_Discover_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).Discover(ctx, req.(*DiscoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CheckAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAvailabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CheckAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CheckAvailability_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CheckAvailability(ctx, req.(*CheckAvailabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CollectDeviceInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectDeviceInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CollectDeviceInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CollectDeviceInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CollectDeviceInformation(ctx, req.(*CollectDeviceInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CollectBasicDeviceInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectBasicDeviceInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CollectBasicDeviceInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CollectBasicDeviceInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CollectBasicDeviceInformation(ctx, req.(*CollectBasicDeviceInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CollectPortInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectPortInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CollectPortInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CollectPortInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CollectPortInformation(ctx, req.(*CollectPortInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CollectBasicPortInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectBasicPortInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CollectBasicPortInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CollectBasicPortInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CollectBasicPortInformation(ctx, req.(*CollectBasicPortInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CollectConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CollectConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CollectConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CollectConfig(ctx, req.(*CollectConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Poller_CollectNeighbours_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectNeighboursRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PollerServer).CollectNeighbours(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Poller_CollectNeighbours_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PollerServer).CollectNeighbours(ctx, req.(*CollectNeighboursRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Poller_ServiceDesc is the grpc.ServiceDesc for Poller service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Poller_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Poller",
	HandlerType: (*PollerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestTerminal",
			Handler:    _Poller_RequestTerminal_Handler,
		},
		{
			MethodName: "ListTerminals",
			Handler:    _Poller_ListTerminals_Handler,
		},
		{
			MethodName: "GetTerminal",
			Handler:    _Poller_GetTerminal_Handler,
		},
		{
			MethodName: "Discover",
			Handler:    _Poller_Discover_Handler,
		},
		{
			MethodName: "CheckAvailability",
			Handler:    _Poller_CheckAvailability_Handler,
		},
		{
			MethodName: "CollectDeviceInformation",
			Handler:    _Poller_CollectDeviceInformation_Handler,
		},
		{
			MethodName: "CollectBasicDeviceInformation",
			Handler:    _Poller_CollectBasicDeviceInformation_Handler,
		},
		{
			MethodName: "CollectPortInformation",
			Handler:    _Poller_CollectPortInformation_Handler,
		},
		{
			MethodName: "CollectBasicPortInformation",
			Handler:    _Poller_CollectBasicPortInformation_Handler,
		},
		{
			MethodName: "CollectConfig",
			Handler:    _Poller_CollectConfig_Handler,
		},
		{
			MethodName: "CollectNeighbours",
			Handler:    _Poller_CollectNeighbours_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenTerminal",
			Handler:       _Poller_OpenTerminal_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "core.proto",
}

const (
	Commander_ConfigureStanza_FullMethodName = "/core.Commander/ConfigureStanza"
)

// CommanderClient is the client API for Commander service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommanderClient interface {
	// configure a configuration stanza on a network element
	ConfigureStanza(ctx context.Context, in *ConfigureStanzaRequest, opts ...grpc.CallOption) (*stanzapb.ConfigureResponse, error)
}

type commanderClient struct {
	cc grpc.ClientConnInterface
}

func NewCommanderClient(cc grpc.ClientConnInterface) CommanderClient {
	return &commanderClient{cc}
}

func (c *commanderClient) ConfigureStanza(ctx context.Context, in *ConfigureStanzaRequest, opts ...grpc.CallOption) (*stanzapb.ConfigureResponse, error) {
	out := new(stanzapb.ConfigureResponse)
	err := c.cc.Invoke(ctx, Commander_ConfigureStanza_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommanderServer is the server API for Commander service.
// All implementations should embed UnimplementedCommanderServer
// for forward compatibility
type CommanderServer interface {
	// configure a configuration stanza on a network element
	ConfigureStanza(context.Context, *ConfigureStanzaRequest) (*stanzapb.ConfigureResponse, error)
}

// UnimplementedCommanderServer should be embedded to have forward compatible implementations.
type UnimplementedCommanderServer struct {
}

func (UnimplementedCommanderServer) ConfigureStanza(context.Context, *ConfigureStanzaRequest) (*stanzapb.ConfigureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureStanza not implemented")
}

// UnsafeCommanderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommanderServer will
// result in compilation errors.
type UnsafeCommanderServer interface {
	mustEmbedUnimplementedCommanderServer()
}

func RegisterCommanderServer(s grpc.ServiceRegistrar, srv CommanderServer) {
	s.RegisterService(&Commander_ServiceDesc, srv)
}

func _Commander_ConfigureStanza_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureStanzaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommanderServer).ConfigureStanza(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Commander_ConfigureStanza_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommanderServer).ConfigureStanza(ctx, req.(*ConfigureStanzaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Commander_ServiceDesc is the grpc.ServiceDesc for Commander service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Commander_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.Commander",
	HandlerType: (*CommanderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigureStanza",
			Handler:    _Commander_ConfigureStanza_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}
